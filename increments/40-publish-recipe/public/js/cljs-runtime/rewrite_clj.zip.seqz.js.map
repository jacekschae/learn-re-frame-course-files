{"version":3,"sources":["rewrite_clj/zip/seqz.cljs"],"sourcesContent":["(ns rewrite-clj.zip.seqz\n  (:refer-clojure :exclude [map get assoc seq? vector? list? map? set?])\n  (:require [rewrite-clj.zip.base :as base]\n            [rewrite-clj.zip.editz :as e]\n            [rewrite-clj.zip.findz :as f]\n            [rewrite-clj.zip.insert :as i]\n            [rewrite-clj.zip.move :as m]\n            [clojure.zip :as z]))\n\n;; ## Predicates\n\n(defn seq?\n  [zloc]\n  (contains?\n    #{:forms :list :vector :set :map}\n    (base/tag zloc)))\n\n(defn list?\n  [zloc]\n  (= (base/tag zloc) :list))\n\n(defn vector?\n  [zloc]\n  (= (base/tag zloc) :vector))\n\n(defn set?\n  [zloc]\n  (= (base/tag zloc) :set))\n\n(defn map?\n  [zloc]\n  (= (base/tag zloc) :map))\n\n;; ## Map Operations\n\n(defn- map-seq\n  [f zloc]\n  {:pre [(seq? zloc)]}\n  (if-let [n0 (m/down zloc)]\n    (some->> (f n0)\n             (iterate\n               (fn [loc]\n                 (if-let [n (m/right loc)]\n                   (f n))))\n             (take-while identity)\n             (last)\n             (m/up))\n    zloc))\n\n(defn map-vals\n  \"Apply function to all value nodes of the given map node.\"\n  [f zloc]\n  {:pre [(map? zloc)]}\n  (loop [loc (m/down zloc)\n         parent zloc]\n    (if-not (and loc (z/node loc))\n      parent\n      (if-let [v0 (m/right loc)]\n        (if-let [v (f v0)]\n          (recur (m/right v) (m/up v))\n          (recur (m/right v0) parent))\n        parent))))\n\n(defn map-keys\n  \"Apply function to all key nodes of the given map node.\"\n  [f zloc]\n  {:pre [(map? zloc)]}\n  (loop [loc (m/down zloc)\n         parent zloc]\n    (if-not (and loc (z/node loc))\n      parent\n      (if-let [v (f loc)]\n        (recur (m/right (m/right v)) (m/up v))\n        (recur (m/right (m/right loc)) parent)))))\n\n(defn map\n  \"Apply function to all value nodes in the given seq node. Iterates over\n   value nodes of maps but over each element of a seq.\"\n  [f zloc]\n  {:pre [(seq? zloc)]}\n  (if (map? zloc)\n    (map-vals f zloc)\n    (map-seq f zloc)))\n\n;; ## Get/Assoc\n\n(defn get\n  \"If a map is given, get element with the given key; if a seq is given, get nth element.\"\n  [zloc k]\n  {:pre [(or (map? zloc) (and (seq? zloc) (integer? k)))]}\n  (if (map? zloc)\n    (some-> zloc m/down (f/find-value k) m/right)\n    (nth\n      (some->> (m/down zloc)\n               (iterate m/right)\n               (take-while identity))\n      k)))\n\n(defn assoc\n  \"Set map/seq element to the given value.\"\n  [zloc k v]\n  (if-let [vloc (get zloc k)]\n    (-> vloc (e/replace v) m/up)\n    (if (map? zloc)\n      (-> zloc\n          (i/append-child k)\n          (i/append-child v))\n      (throw\n        (js/Error.\n          (str \"index out of bounds: \" k))))))\n"],"mappings":"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","names":["rewrite-clj.zip.seqz/seq?","zloc","cljs.core/contains?","rewrite-clj.zip.base/tag","rewrite-clj.zip.seqz/list?","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","rewrite-clj.zip.seqz/vector?","rewrite-clj.zip.seqz/set?","rewrite-clj.zip.seqz/map?","js/Error","rewrite-clj.zip.seqz/map-seq","f","temp__5455__auto__","n0","rewrite-clj.zip.move/down","G__30906","cljs.core/iterate","loc","n","rewrite-clj.zip.move/right","cljs.core.take_while.cljs$core$IFn$_invoke$arity$2","cljs.core/identity","cljs.core/last","rewrite-clj.zip.move/up","rewrite-clj.zip.seqz/map-vals","parent","cljs.core/not","and__4120__auto__","clojure.zip/node","v0","v","rewrite-clj.zip.seqz/map-keys","rewrite-clj.zip.seqz/map","rewrite-clj.zip.seqz/get","k","cljs.core/integer?","G__30910","rewrite_clj.zip.findz.find_value.cljs$core$IFn$_invoke$arity$2","cljs.core.nth.cljs$core$IFn$_invoke$arity$2","G__30911","rewrite-clj.zip.seqz/assoc","vloc","rewrite-clj.zip.editz/replace","rewrite-clj.zip.insert/append-child"]}