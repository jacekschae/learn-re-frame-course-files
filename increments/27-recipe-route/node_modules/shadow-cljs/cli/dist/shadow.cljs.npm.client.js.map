{"version":3,"sources":["shadow/cljs/npm/client.cljs"],"sourcesContent":["(ns shadow.cljs.npm.client\n  (:require [cljs.reader :as reader]\n            [\"readline\" :as rl]\n            [\"net\" :as node-net]\n            [\"fs\" :as fs]\n            [shadow.cljs.npm.util :as util]\n            [clojure.string :as str]))\n\n(defn socket-data [data exit-token error-token]\n  (let [txt (.toString data)]\n    (cond\n      (str/includes? txt exit-token)\n      [:close (-> (str/replace txt exit-token \"\")\n                  (str/trimr))]\n\n      (str/includes? txt error-token)\n      [:exit (-> (str/replace txt error-token \"\")\n                 (str/trimr))]\n\n      :else\n      [:continue txt])))\n\n(defn repl-client\n  \"readline client that tries to maintain a prompt. not quite smart yet.\"\n  [^js socket args]\n  (let [last-prompt-ref\n        (volatile! nil)\n\n        rl\n        (rl/createInterface\n          #js {:input js/process.stdin\n               :output js/process.stdout\n               :completer\n               (fn [prefix callback]\n                 (let [last-prompt @last-prompt-ref]\n                   ;; without a prompt we can't autocomplete\n                   (if-not last-prompt\n                     (callback nil (clj->js [[] prefix]))\n\n                     ;; FIXME: hook this up properly\n                     (callback nil (clj->js [[] prefix])))))})\n\n        write\n        (fn [text]\n          ;; assume that everything we send is (read) which reads something\n          ;; we can never autocomplete\n          ;; and only a new prompt enables it\n          (vreset! last-prompt-ref nil)\n          (.write socket text))\n\n        repl-mode?\n        false\n\n        exit-token\n        (str (random-uuid))\n\n        error-token\n        (str (random-uuid))\n\n        stop!\n        (fn []\n          (.close rl)\n          (.end socket)\n          (println))]\n\n    (println \"shadow-cljs - connected to server\")\n\n    ;; FIXME: this is an ugly hack that will be removed soon\n    ;; its just a quick way to interact with the server without a proper API protocol\n    (write (str \"(shadow.cljs.devtools.cli/from-remote \" (pr-str exit-token) \" \" (pr-str error-token) \" \" (pr-str (into [] args)) \")\\n\"))\n\n    (.on rl \"line\"\n      (fn [line]\n        (write (str line \"\\n\"))))\n\n    ;; CTRL+D closes the rl\n    (.on rl \"close\"\n      (fn []\n        (stop!)))\n\n    (.on socket \"data\"\n      (fn [data]\n        (let [[action txt]\n              (socket-data data exit-token error-token)]\n\n          (js/process.stdout.write txt)\n\n          (case action\n            :close\n            (stop!)\n\n            :exit\n            (js/process.exit 1)\n\n            :continue\n            (let [prompts\n                  (re-seq #\"\\[(\\d+):(\\d+)\\]\\~([^=> \\n]+)=> \" txt)]\n\n              (doseq [[prompt root-id level-id ns :as m] prompts]\n                (vreset! last-prompt-ref {:text prompt\n                                          :ns (symbol ns)\n                                          :level (js/parseInt level-id 10)\n                                          :root (js/parseInt root-id 10)})\n                (.setPrompt rl prompt))\n\n              (when @last-prompt-ref\n                (.prompt rl true)))))))\n\n    (.on socket \"end\" #(.close rl))\n    ))\n\n(defn socket-pipe\n  \"client that just pipes everything through the socket without any processing\"\n  [^js socket args]\n  (let [write\n        (fn [text]\n          (.write socket text))\n\n        exit-token\n        (str (random-uuid))\n\n        error-token\n        (str (random-uuid))\n\n        stop!\n        (fn []\n          (.end socket))\n\n        stdin-read\n        (fn [buffer]\n          (write (.toString buffer)))]\n\n    (write (str \"(shadow.cljs.devtools.cli/from-remote \" (pr-str exit-token) \" \" (pr-str error-token) \" \" (pr-str (into [] args)) \")\\n\"))\n\n    (js/process.stdin.on \"data\" stdin-read)\n    (js/process.stdin.on \"close\" stop!)\n\n    (.on socket \"data\"\n      (fn [data]\n        (let [[action txt]\n              (socket-data data exit-token error-token)]\n\n          (js/process.stdout.write txt)\n\n          (case action\n            :close\n            (stop!)\n\n            :exit\n            (js/process.exit 1)\n\n            :continue\n            nil))))\n\n    (.on socket \"end\"\n      (fn []\n        (js/process.stdin.removeListener \"data\" stdin-read)\n        (js/process.stdin.removeListener \"close\" stop!)\n        ))))\n\n(defn run\n  \"attempts to connect to running server. if the connect fails calls callback\"\n  [project-root config server-port-file opts args fallback]\n  (let [cli-repl\n        (-> (util/slurp server-port-file)\n            (js/parseInt 10))]\n\n    (if-not (pos-int? cli-repl)\n      (prn [:no-socket-repl-port server-port-file cli-repl])\n      (let [connect-listener\n            (fn [err]\n              (this-as socket\n                (if (get-in opts [:options :stdin])\n                  (socket-pipe socket args)\n                  (repl-client socket args))))\n\n            socket\n            (node-net/connect\n              #js {:port cli-repl\n                   :host \"127.0.0.1\"\n                   :timeout 1000}\n              connect-listener)]\n\n        (.on socket \"error\"\n          (fn [err]\n            (println \"shadow-cljs - socket connect failed, server process dead?\")\n            (fallback err)\n            ))))))\n\n"],"mappings":";;;;;;;;AAQA,AAAA,AAAMA,AAAaC,AAAKC,AAAWC;AAAnC,AACE,AAAMC,AAAI,AAAWH;AAArB,AACE,AACE,AAACI,AAAcD,AAAIF;AADrB,AAAA,AAEc,AAAA,AAACI,AAAYF,AAAIF,AACjB,AAACK;;AAHf,AAKE,AAACF,AAAcD,AAAID;AALrB,AAAA,AAMa,AAAA,AAACG,AAAYF,AAAID,AACjB,AAACI;;AAPd,AAAA,AAAA,AAUaH;;;;;AAEjB;;;AAAA,AAAMI,AAECC,AAAOC;AAFd,AAGE,AAAMC,AACA,AAAA,AAACC;AAEDC,AACA,AAAAC,AAAA,AACcE,AACCC,AAER;AAAKC,AAAOC;AAAZ,AACE,AAAA,AAAAC,AAAMC,AAAaV;AAAnB,AAEE,AAAA,AAAAW,AAAQD;AACN,AAAAE,AAAA;AAAAC,AAAc,AAAA,AAAA,AAACC,AAAYP;AAA3B,AAAA,AAAAK,AAAAC,AAAAD,AAAAC,AAACL,AAAAA,AAAAA;;AAGD,AAAAO,AAAA;AAAAC,AAAc,AAAA,AAAA,AAACF,AAAYP;AAA3B,AAAA,AAAAQ,AAAAC,AAAAD,AAAAC,AAACR,AAAAA,AAAAA;;;;AAXd,AAAA,AAAAL,AAACC;;AAaDa,AACA;AAAKC;AAAL,AAIE,AAAA,AAACC,AAAQnB;;AACT,AAAQF,AAAOoB;;;AAvBvB,AAyBME;AAGA7B,AACA,AAAK,AAAC8B;AAEN7B,AACA,AAAK,AAAC6B;AAENC,AACA;;AAAA,AACE,AAAQpB;;AACR,AAAMJ;;AACN,AAACyB;;;AAtCT,AAwCE,AAAA,AAACC;;AAID,AAACP,AAAM,AAAA,AAAA,AAAA,AAAA,AAA8C,AAACQ,AAAOlC,AAAgB,AAACkC,AAAOjC,AAAiB,AAACiC,AAAO,AAAA,AAACC,AAAQ3B;;AAEvH,AAAA,AAAKG,AACH,AAAKyB;AAAL,AACE,AAACV,AAAM,AAAA,AAAKU;;;AAGhB,AAAA,AAAKzB,AACH;AAAA,AACE,AAACoB;;;AAEL,AAAA,AAAKxB,AACH,AAAKR;AAAL,AACE,AAAAsC,AACM,AAACvC,AAAYC,AAAKC,AAAWC;AADnC,AAAAqC,AAAAD,AAAA,AAAA,AAAOE;AAAP,AAAAD,AAAAD,AAAA,AAAA,AAAcnC;AAAd,AAGE,AAACsC,AAAwBtC;;AAEzB,AAAAuC,AAAMF;AAANE,AAAA,AAAA,AAAAA,AAAAC,AAAA,AAAAD,AAAA;AAAA,AAAA,AAAAA;AAAA;AAEE,AAACV;;;AAFH;AAKE,AAAA,AAACa;;;AALH;AAQE,AAAMC,AACA,AAAA,AAACC,AAA0C5C;AADjD,AAGE,AAAA6C,AAAA,AAAAC,AAA2CH;AAA3CI,AAAA;AAAAC,AAAA;AAAAC,AAAA;;AAAA,AAAA,AAAA,AAAA,AAAAA,AAAAD;AAAA,AAAAE,AAAA,AAAAH,AAAAE;AAAA,AAAAb,AAAAc,AAAA,AAAA,AAASU;AAAT,AAAAxB,AAAAc,AAAA,AAAA,AAAgBW;AAAhB,AAAAzB,AAAAc,AAAA,AAAA,AAAwBY;AAAxB,AAAA1B,AAAAc,AAAA,AAAA,AAAiCa;AAAjCb,AAAwCc;AAAxC,AAAA,AACE,AAAA,AAAA,AAAA,AAAA,AAAA,AAACtC,AAAQnB,AAAuBqD,AACF,AAACK,AAAOF,AACL,AAAA,AAACG,AAAYJ,AACd,AAAA,AAACI,AAAYL;;AAC7C,AAAYpD,AAAGmD;;AALjB;AAAA,AAAAf;AAAAE;AAAAC;AAAA,AAAAC,AAAA;;;;;;;AAAA,AAAAE,AAAA,AAAAL,AAAAD;AAAA,AAAA,AAAAM;AAAA,AAAA,AAAAN,AAAAM;AAAA,AAAA,AAAA,AAAAC,AAAAP;AAAA,AAAAQ,AAAA,AAAAC,AAAAT;AAAA,AAAA,AAAA,AAAAU,AAAAV;AAAAQ;AAAA,AAAAG,AAAAH;AAAA;;;;;;;AAAA,AAAAI,AAAA,AAAAC,AAAAb;AAAA,AAAAT,AAAAqB,AAAA,AAAA,AAASG;AAAT,AAAAxB,AAAAqB,AAAA,AAAA,AAAgBI;AAAhB,AAAAzB,AAAAqB,AAAA,AAAA,AAAwBK;AAAxB,AAAA1B,AAAAqB,AAAA,AAAA,AAAiCM;AAAjCN,AAAwCO;AAAxC,AAAA,AACE,AAAA,AAAA,AAAA,AAAA,AAAA,AAACtC,AAAQnB,AAAuBqD,AACF,AAACK,AAAOF,AACL,AAAA,AAACG,AAAYJ,AACd,AAAA,AAACI,AAAYL;;AAC7C,AAAYpD,AAAGmD;;AALjB;AAAA,AAAA,AAAAD,AAAAd;AAAA;AAAA;AAAA;;;;;;;;AAAA;;;;;AAOA,AAAA,AAAA7B,AAAOT;AAAP,AACE,AAAA,AAASE;;AADX;;;;;AAlBJ,AAAA,AAAAgC,AAAA,AAAA,AAAAF;;;;;AAqBN,AAAA,AAAA,AAAKlC;AAAL,AAAmB,AAAQI;;;AAG/B;;;AAAA,AAAM0D,AAEC9D,AAAOC;AAFd,AAGE,AAAMkB,AACA,AAAKC;AAAL,AACE,AAAQpB,AAAOoB;;AAEjB3B,AACA,AAAK,AAAC8B;AAEN7B,AACA,AAAK,AAAC6B;AAENC,AACA;;AAAA,AACE,AAAMxB;;;AAER+D,AACA;AAAKC;AAAL,AACE,AAAC7C,AAAM,AAAW6C;;;AAhB1B,AAkBE,AAAC7C,AAAM,AAAA,AAAA,AAAA,AAAA,AAA8C,AAACQ,AAAOlC,AAAgB,AAACkC,AAAOjC,AAAiB,AAACiC,AAAO,AAAA,AAACC,AAAQ3B;;AAEvH,AAAA,AAACgE,AAA2BF;;AAC5B,AAAA,AAACE,AAA4BzC;;AAE7B,AAAA,AAAKxB,AACH,AAAKR;AAAL,AACE,AAAA0E,AACM,AAAC3E,AAAYC,AAAKC,AAAWC;AADnC,AAAAqC,AAAAmC,AAAA,AAAA,AAAOlC;AAAP,AAAAD,AAAAmC,AAAA,AAAA,AAAcvE;AAAd,AAGE,AAACsC,AAAwBtC;;AAEzB,AAAAwE,AAAMnC;AAANmC,AAAA,AAAA,AAAAA,AAAAhC,AAAA,AAAAgC,AAAA;AAAA,AAAA,AAAAA;AAAA;AAEE,AAAC3C;;;AAFH;AAKE,AAAA,AAACa;;;AALH;AAAA;;;;AAAA,AAAA,AAAAD,AAAA,AAAA,AAAA+B;;;;;AAUN,AAAA,AAAKnE,AACH;AAAA,AACE,AAAA,AAACoE,AAAuCL;;AACxC,AAAA,AAACK,AAAwC5C;;;AAGjD;;;AAAA,AAAM6C,AAEHC,AAAaC,AAAOC,AAAiBC,AAAKxE,AAAKyE;AAFlD,AAGE,AAAMC,AACI,AAACC,AAAWJ,AACZ,AAAA,AAACX;AAFX,AAIE,AAAA,AAAQ,AAACgB,AAASF;AAChB,AAAA,AAAA,AAACG,AAA0BN,AAAiBG;;AAC5C,AAAMI,AACA;AAAKC;AAAL,AACE,AAAA,AAAShF;AAAT,AACE,AAAI,AAAA,AAAA,AAAA,AAACiF,AAAOR;AACV,AAACX,AAAY9D,AAAOC;;AACpB,AAACF,AAAYC,AAAOC;;;;AAE1BD,AACA,AAAAkF,AAAA,AAAA,AAAA,AACaP;AADbQ,AAIEJ;AAJF,AAAA,AAAAG,AAAAC,AAACC;;AARP,AAcE,AAAA,AAAKpF,AACH,AAAKgF;AAAL,AACE,AAAA,AAACtD;;AACD,AAACgD,AAAAA,AAAAA,AAASM,AAAAA","names":["shadow.cljs.npm.client/socket-data","data","exit-token","error-token","txt","clojure.string/includes?","clojure.string/replace","clojure.string/trimr","shadow.cljs.npm.client/repl-client","socket","args","last-prompt-ref","cljs.core/volatile!","rl","G__80222","js/shadow.js.shim.module$readline.createInterface","js/process.stdin","js/process.stdout","prefix","callback","cljs.core/deref","last-prompt","cljs.core/not","G__80224","G__80225","cljs.core/clj->js","G__80226","G__80227","write","text","cljs.core/vreset!","repl-mode?","cljs.core/random-uuid","stop!","cljs.core/println","cljs.core.println.cljs$core$IFn$_invoke$arity$variadic","cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic","cljs.core.into.cljs$core$IFn$_invoke$arity$2","line","vec__80314","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","action","js/process.stdout.write","G__80317","cljs.core/Keyword","js/Error","js/process.exit","prompts","cljs.core/re-seq","seq__80320","cljs.core/seq","chunk__80321","count__80322","i__80323","vec__80342","temp__5457__auto__","cljs.core/chunked-seq?","c__4550__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/count","vec__80345","cljs.core/first","cljs.core/next","prompt","root-id","level-id","ns","m","cljs.core.symbol.cljs$core$IFn$_invoke$arity$1","js/parseInt","shadow.cljs.npm.client/socket-pipe","stdin-read","buffer","js/process.stdin.on","vec__80391","G__80394","js/process.stdin.removeListener","shadow.cljs.npm.client/run","project-root","config","server-port-file","opts","fallback","cli-repl","shadow.cljs.npm.util/slurp","cljs.core/pos-int?","cljs.core.prn.cljs$core$IFn$_invoke$arity$variadic","connect-listener","err","cljs.core.get_in.cljs$core$IFn$_invoke$arity$2","G__80244","G__80245","js/shadow.js.shim.module$net.connect"]}